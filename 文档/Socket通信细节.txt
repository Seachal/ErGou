PB收发协议：
128 字节的待加密数据 (使用RSA加密)
===============================================================================
| 4Bytes ProtoBuf数据长度 | ProtoBuf 数据(平台、版本号、AES KEY)| 不足128字节的填0 |
===============================================================================

AES KEY 握手发送数据
==========================================================
| 4Bytes 数据长度 | 4Bytes 命令 | 128字节加密ProtoBuf 数据  |
==========================================================

发送时待加密的数据，使用AES KEY加密(发送除AESKey之外的指令) 
============================================
4Bytes ProtoBuf数据长度 | 请求ProtoBuf 数据  |
============================================

接收完整协议段
===============================================================================================
| 4Bytes 数据长度 | 4Bytes 命令 | 使用AES KEY加密的 4Bytes状态码 + ProtoBuf length + ProtoBuf 数据 |
===============================================================================================

发送完整协议段
=========================================================================================
| 4Bytes 数据长度 | 4Bytes 命令 | 使用AES KEY加密的 4Bytes ProtoBuf length + ProtoBuf 数据 |
=========================================================================================

// 请求步骤
1.连接后台Socket，成功后回调。
2.AesKey握手(发送AesKey请求，处理AesKeyResponse)，并返回离线消息数，假若消息数为0，ProtoBufferData为空
3.握手成功，发送Socket心跳包，根据未读消息数量判断是否获取未读消息
4.分配用户对象

// Socket代码相关注意点说明：
1.发送AESKey的时候需要用RSA加密
2.发送其他指令的时候，需要使用AESKey加密
3.发送PB和接收数据的时候，需要根据PB数据的length长度>512，使用ZLib库对数据进行压缩和解压
4.数据接收有两种，一种是REQ，一种是RSP。REQ返回的数据默认不带code，RSP返回的数据默认都是带code。（code指的是服务器端状态码，后期解析数据需要根据Code==0判断请求是否正确）
5.接收到数据之后，根据协议，需要处理最外层的指令REQ/RSP目标指令command，后面根据command执行不同的socketResponse处理。
6.因为SocketManager是开创了一个SocketThread去执行Socket的相关操作，所以回调均为子线程回调，这里使用了Handler作为线程切换控制器


// 重连机制
1.断开分为如下几种情况：
	a.远程服务器端主动断开
	b.客户端主动断开
	c.网络导致的主动断开

对于a、c来说，因为Socket通道是双工模式的，所以当一端断开的时候是不会发送离线通知给另一端，用心跳包也存在问题。
所以在a、c情况下，假若向Socket读取或者写入数据的时候就会报错，然后在catch到Exception的时候使用CountDownTimer去实现重连

针对b情况来说，主动断开（如用户退出登陆），直接单方断开Socket连接并且释放资源，待重新登录的时候重新创建Socket以保证数据的准确性

// 头部广播获取与处理
1.进入ChatActivity页面，获取广播数据
2.收到广播单条数据推送，插入之前广播数据列表。（详细看P层实现，主要是获取到当前index，然后插入下一条。）

// 发送消息（涉及到几种异常情况）
1.客户端发送消息，将消息添加到待发送队列，同时添加到P层的一个映射reqId和message的 ArrayMap（用户标记消息重发），和本地数据库
2.发送消息，从P层传递到SocketManager进行发送处理。
3.消息回调会在P层sendMessageCallBack回调收到消息是否发送成功（此时改变UI的状态），删除P层映射表数据
4.此时等待后端回应单播消息指令IM_REQ_UNICAST_SAY，收到后P层会回调replyMessageCallBack，此时新的数据入库

// 重发消息（主动点击重发与进入页面自动重发）
1.主动重发：
	a.在内存里面有一个映射reqId和message的 ArrayMap。当失败的时候，根据reqId查询出对应的message
	b.拿出Message后，走Socket发送消息流程
2.页面自动重发：
	a.进入页面，查询数据库发送失败状态（发送中与发送失败）消息数据，存入内存映射reqId和message的 ArrayMap
	b.***不能直接for发送数据，不然服务器端处理会出现问题*** 
	c.所以每次发送一条消息成功回调之后，再读取ArrayMap的下一条待发送信息，如此循环。直到ArrayMap数据为空

// 发送消息异常情况说明：
1.用户没有分配到机器人
	a.当获取不到机器人信息（业务层而言就是缺失了当前消息的toId），Socket还是有效的，服务器端还是会响应，但是发送的消息均会失败。
	b.当缺少机器人信息，按照发送的正常流程，消息也会添加到一个映射reqId和message的 ArrayMap，等待发送。
	c.获取机器人信息，发送与重发的时机都会重新刷新机器人信息，假若刷新到机器人信息。在机器人消息回调，执行类型---页面消息自动重发逻辑

2.断网，服务器主动断开后，重新连上Socket的重发处理
	a.因为断网后或者服务器端主动断开，都会走重连的逻辑。因为重连逻辑涉及到了机器人信息的重新获取，所以在P层的机器人信息回调即可发送数据
	b.发送逻辑与面自动重发一致。




